<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Dodge the Bricks — Multi-Mode</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    :root { --overlay: rgba(0,0,0,.8); }
    body { font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif; background:black; height:100vh; display:grid; place-items:center; margin:0; }
    #game { 
        position:relative; 
        width:100%; 
        height:100%; 
        max-width: 900px; 
        max-height: 650px; 
        background-image: url('wallpaper.png');
        background-size: cover;
        background-position: center;
        border-radius:16px; 
        overflow:hidden; 
        box-shadow: 0 10px 30px rgba(0,0,0,.12); 
        }
    canvas { display:block; width:100%; height:100%; background:transparent; }
    /* Overlays */
    .overlay { position:absolute; inset:0; display:none; align-items:center; justify-content:center; background:var(--overlay); color:#fff; z-index:10; }
    .overlay.show { display:flex; }
    .panel { width:min(92%,720px); background:#0b1020; border:1px solid rgba(255,255,255,.1); border-radius:16px; padding:24px; box-shadow: 0 10px 30px rgba(0,0,0,.35); }
    .btn { padding:.75rem 1.25rem; font-weight:700; border-radius:.75rem; border:0; cursor:pointer; box-shadow:0 6px 16px rgba(0,0,0,.15); transition: transform .1s ease, opacity .15s ease; }
    .btn:hover { transform: translateY(-1px); }
    .btn:disabled { opacity:.5; cursor:not-allowed; transform:none; }
    .btn-primary { background:#3b82f6; color:#fff; }
    .btn-primary:hover { background:#2563eb; }
    .btn-ghost { background:transparent; border:1px solid rgba(255,255,255,.2); color:#fff; }
    .btn-danger { background:#ef4444; color:#fff; }
    .btn-green { background:#22c55e; color:#0b1020; }
    .btn-purple { background:#8b5cf6; color:#fff; }
    .row { display:flex; flex-wrap:wrap; gap:12px; }
    .chip { padding:.5rem .75rem; border-radius:.75rem; background:#111827; border:1px solid rgba(255,255,255,.15); cursor:pointer; }
    .chip.selected { background:#6d28d9; }
    .kbd { padding:.25rem .5rem; border:1px solid #e5e7eb; border-bottom-width:3px; border-radius:.5rem; background:#fff; color:#111827; font-weight:700; }
    /* Top-right in-game menu button */
    #ingameMenuBtn { position:absolute; right:10px; top:10px; z-index:5; display:none; }
    /* Game over panel tweak */
    .table { width:100%; border-collapse: collapse; margin-top:10px; }
    .table th, .table td { border-bottom:1px solid rgba(255,255,255,.1); padding:8px 10px; text-align:left; }
  </style>
</head>
<body>
  <div id="game">
    <canvas id="canvas"></canvas>

    <!-- In-game Menu button -->
    <button id="ingameMenuBtn" class="btn btn-ghost">Menu</button>

    <!-- Start Menu -->
    <div id="menu" class="overlay show">
      <div class="panel">
        <h1 class="text-3xl md:text-4xl font-extrabold mb-3">Dodge the Bricks</h1>
        <p class="opacity-80 mb-4">Select a mode, check the instructions, then press Start.</p>

        <h2 class="text-xl font-bold mb-2">Mode</h2>
        <div class="row mb-4" id="modeChips">
          <button class="chip" data-mode="solo">Solo</button>
          <button class="chip" data-mode="coop">Co-op</button>
          <button class="chip" data-mode="multi">Multiplayer (2P)</button>
          <button class="chip" data-mode="triple">Triple Player (3P)</button>
        </div>

        <div class="row mb-6">
          <button id="instructionsBtn" class="btn btn-ghost">Instructions</button>
          <button id="startBtn" class="btn btn-primary" disabled>Start</button>
        </div>

        <div class="text-sm opacity-80 leading-relaxed">
          <p><strong>Notes:</strong></p>
          <ul class="list-disc ml-6">
            <li><em>Co-op</em>: falling-brick <strong>immunity</strong> for the non-triggering player.</li>
            <li><em>Multiplayer/Triple</em>: <strong>no immunity</strong>, elimination, last player standing wins.</li>
          </ul>
        </div>
      </div>
    </div>

    <!-- Instructions -->
    <div id="instructions" class="overlay">
      <div class="panel">
        <h2 class="text-2xl font-bold mb-3">Instructions</h2>
        <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4">
          <div class="p-3 rounded-xl bg-indigo-900/40 border border-white/10">
            <h3 class="font-bold mb-2">Player 1</h3>
            <div class="space-x-2">
              <span class="kbd">W</span><span class="opacity-70">jump</span>
            </div>
            <div class="space-x-2">
              <span class="kbd">S</span><span class="opacity-70">duck</span>
            </div>
            <div class="space-x-2">
              <span class="kbd">A</span><span class="opacity-70">left</span>
              <span class="kbd">D</span><span class="opacity-70">right</span>
            </div>
          </div>
          <div class="p-3 rounded-xl bg-indigo-900/40 border border-white/10">
            <h3 class="font-bold mb-2">Player 2</h3>
            <div class="space-x-2">
              <span class="kbd">↑</span><span class="opacity-70">jump</span>
            </div>
            <div class="space-x-2">
              <span class="kbd">↓</span><span class="opacity-70">duck</span>
            </div>
            <div class="space-x-2">
              <span class="kbd">←</span><span class="opacity-70">left</span>
              <span class="kbd">→</span><span class="opacity-70">right</span>
            </div>
          </div>
          <div class="p-3 rounded-xl bg-indigo-900/40 border border-white/10">
            <h3 class="font-bold mb-2">Player 3</h3>
            <div class="space-x-2">
              <span class="kbd">I</span><span class="opacity-70">jump</span>
            </div>
            <div class="space-x-2">
              <span class="kbd">K</span><span class="opacity-70">duck</span>
            </div>
            <div class="space-x-2">
              <span class="kbd">J</span><span class="opacity-70">left</span>
              <span class="kbd">L</span><span class="opacity-70">right</span>
            </div>
          </div>
        </div>
        <p class="opacity-80 mb-4">
          Bricks spawn above. When a brick’s Y reaches a player’s Y, that vertical brick <strong>drops fast</strong>.<br/>
          Co-op: the non-triggering player is immune to that specific falling brick while it falls. Competitive modes: no immunity.
        </p>
        <button id="backFromInstructions" class="btn btn-purple">Back</button>
      </div>
    </div>

    <!-- Pause / Confirm Menu -->
    <div id="pauseOverlay" class="overlay">
      <div class="panel">
        <h3 class="text-xl font-bold mb-2">Paused</h3>
        <p class="opacity-80 mb-4">Are you sure you want to leave this game?</p>
        <div class="row">
          <button id="resumeBtn" class="btn btn-green">Resume</button>
          <button id="restartBtn" class="btn btn-primary">Restart Game</button>
          <button id="toMenuBtn" class="btn btn-danger">Main Menu</button>
        </div>
      </div>
    </div>

    <!-- Game Over / Results -->
    <div id="gameOver" class="overlay">
      <div class="panel">
        <h2 class="text-2xl font-bold mb-2">Results</h2>
        <div id="resultsBlock" class="mb-4 text-white/90"></div>
        <div class="row">
          <button id="playAgainBtn" class="btn btn-primary">Play Again</button>
          <button id="gameOverMenuBtn" class="btn btn-ghost">Main Menu</button>
        </div>
      </div>
    </div>
  </div>

  <script>
  (() => {
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    // UI refs
    const menu = document.getElementById('menu');
    const modeChips = document.getElementById('modeChips');
    const startBtn = document.getElementById('startBtn');
    const instructionsBtn = document.getElementById('instructionsBtn');
    const instructions = document.getElementById('instructions');
    const backFromInstructions = document.getElementById('backFromInstructions');
    const pauseOverlay = document.getElementById('pauseOverlay');
    const ingameMenuBtn = document.getElementById('ingameMenuBtn');
    const resumeBtn = document.getElementById('resumeBtn');
    const restartBtn = document.getElementById('restartBtn');
    const toMenuBtn = document.getElementById('toMenuBtn');
    const gameOver = document.getElementById('gameOver');
    const resultsBlock = document.getElementById('resultsBlock');
    const playAgainBtn = document.getElementById('playAgainBtn');
    const gameOverMenuBtn = document.getElementById('gameOverMenuBtn');

    // Sprites
    const erenSprite = new Image();
    erenSprite.src = 'eren.png';

    const kimetsuSprite = new Image();
    kimetsuSprite.src = 'kimetsu.png';

    const rengokuSprite = new Image();
    rengokuSprite.src = 'rengoku.png';

    const cursedImg = new Image();
    cursedImg.src = "cursed.png";


    // State
    const settings = {
      playerSpeed: 8,
      rowSpawnRate: 240,
      brickSpeed: 1.6,
      baseBrickSize: 40,
      brickMargin: 25,
      jumpPower: 12,
      gravity: 0.5,
      fastFallSpeed: 30
    };

    let gameState = 'menu'; // 'menu' | 'instructions' | 'playing' | 'paused' | 'gameover'
    let mode = null; // 'solo' | 'coop' | 'multi' | 'triple'

    // Game vars
    let score = 0;
    let players = [];          // array of Player
    let bricks = [];           // array of Brick
    let rowSpawnCounter = 0;
    let verticalRowCount = 0;
    let isOver = false;
    let rafId = null;
    let listenersAdded = false;
    let lastTimestamp = 0;

    // Competitive stats
    let deathOrder = []; // {id, time}

    function resize() {
      const w = Math.min(900, document.getElementById('game').clientWidth);
      const h = Math.min(650, document.getElementById('game').clientHeight);
      canvas.width = w;
      canvas.height = h;
    }
    resize();
    window.addEventListener('resize', () => { if (gameState !== 'playing') resize(); });

    // Player
    function Player(id, x, y, controls, sprite = erenSprite, frameW = 57, frameH = 76) {
      this.id = id;
      this.x = x; this.y = y; this.initialY = y;
      this.sprite = sprite;
      this.drawWidth = frameW * 1.2;  // scale factor
      this.drawHeight = frameH * 1.2;
      this.frameWidth = frameW;
      this.frameHeight = frameH;
      // --- PLAYER-SPECIFIC ADJUSTMENTS ---
        if (this.id === 1) {
            // Move Player 1 up a bit
            this.y -= 10;          
            this.initialY -= 15;   // adjust ground level too
            // Scale Player 1 slightly bigger in width
            this.drawWidth *= 1.2;
            this.drawHeight *= 1.1;
        }
        if (this.id === 2) {
            // Scale Player 2 slightly bigger
            this.drawWidth *= 1.2;
            this.drawHeight *= 1.2;
        }
        if (this.id === 3) {
            // Scale Player 3 slightly bigger
            this.y -= 8;          
            this.initialY -= 10;   // adjust ground level too
            this.drawWidth *= 1.1;
            this.drawHeight *= 1.2;
        }
      this.isLeft = false; this.isRight = false; this.isDown = false;
      this.facing = 'right';
      this.yv = 0;
      this.col = 0; this.row = 0; this.timer = 0; this.step = 6;
      this.alive = true;
      this.controls = controls;
      this.survivalTime = 0;

      this.update = function(dt) {
        if (!this.alive) return;

        if (this.isLeft)  this.x -= settings.playerSpeed;
        if (this.isRight) this.x += settings.playerSpeed;

        this.y += this.yv;
        this.yv += settings.gravity;
        if (this.y >= this.initialY) { this.y = this.initialY; this.yv = 0; }

        if (this.x < 0) this.x = 0;
        if (this.x + this.drawWidth > canvas.width) this.x = canvas.width - this.drawWidth;

        // Animation logic
    // ---------------------------
    if (this.sprite === kimetsuSprite) {
        if (!this.animFrame) this.animFrame = 0;

        this.timer++;
        if (this.timer >= this.step) {
            this.timer = 0;
            this.animFrame++;
        }

        // Stand (0–8 = 9 frames)
        if (!this.isLeft && !this.isRight && this.y === this.initialY && !this.isDown) {
            if (this.animFrame >= 9) this.animFrame = 0;
            this.col = 0 + this.animFrame;
        }
        // Run (9–20 = 12 frames)
        else if (this.isLeft || this.isRight) {
            if (this.animFrame >= 12) this.animFrame = 0;
            this.col = 9 + this.animFrame;
        }
        // Jump (21–33 = 13 frames)
        else if (this.y < this.initialY) {
            if (this.animFrame >= 13) this.animFrame = 0;
            this.col = 21 + this.animFrame;
        }
        // Crouch (57–63 = 9 frames)
        else if (this.isDown && this.y === this.initialY) {
            if (this.animFrame >= 9) this.animFrame = 0;
            this.col = 57 + this.animFrame;
        }

        this.row = 0; // all frames are on row 0

    } else if (this.sprite === rengokuSprite) {
        if (!this.animFrame) this.animFrame = 0;

        this.timer++;
        if (this.timer >= this.step) {
            this.timer = 0;
            this.animFrame++;
        }

        // Standing (frames 0–3)
        if (!this.isLeft && !this.isRight && this.y === this.initialY && !this.isDown) {
            if (this.animFrame < 0 || this.animFrame > 3) this.animFrame = 0;
            this.col = this.animFrame;
        }
        // Running (frames 5–13)
        else if (this.isLeft || this.isRight) {
            if (this.animFrame < 5 || this.animFrame > 13) this.animFrame = 5;
            this.col = this.animFrame;
        }
        // Jump (frames 23–34)
        else if (this.y < this.initialY) {
            if (this.animFrame < 26 || this.animFrame > 34) this.animFrame = 26;
            this.col = this.animFrame;
        }
        // Crouch (frames 53–59)
        else if (this.isDown && this.y === this.initialY) {
            if (this.animFrame < 53 || this.animFrame > 59) this.animFrame = 53;
            this.col = this.animFrame;
        }
    } else {
        if (!this.animFrame) this.animFrame = 0;

        this.timer++;
        if (this.timer >= this.step) {
            this.timer = 0;
            this.animFrame++;
        }

        // Stand
        if (!this.isLeft && !this.isRight && this.y === this.initialY && !this.isDown) {
            this.row = 0;
            if (this.animFrame > 5) this.animFrame = 0;
            this.col = this.animFrame;
        }
        // Run
        else if (this.isLeft || this.isRight) {
            this.row = 2;
            if (this.animFrame > 11) this.animFrame = 0;
            this.col = this.animFrame;
        }
        // Jump
        else if (this.y < this.initialY) {
            this.row = 3;
            if (this.animFrame > 7) this.animFrame = 0;
            this.col = this.animFrame;
        }
        // Crouch
        else if (this.isDown && this.y === this.initialY) {
            this.row = 1;
            if (this.animFrame > 5) this.animFrame = 0;
            this.col = this.animFrame;
        }
    }

    // survival timer
    this.survivalTime += dt;

     // --- CURSED SPRITE FRAME CYCLING ---
    if (!this.cursedFrame) this.cursedFrame = 0;
    if (!this.cursedTimer) this.cursedTimer = 0;

    this.cursedTimer++;
    if (this.cursedTimer >= this.step) {
        this.cursedTimer = 0;
        this.cursedFrame = (this.cursedFrame + 1) % 6; // loop 0..5
    }
    
  };


      this.draw = function() {
        if (!this.alive) return;

        let sx, sy;

        if (this.sprite === kimetsuSprite) {
            const cols = 10; // kimetsu has 10 columns
            sx = (this.col % cols) * this.frameWidth;
            sy = Math.floor(this.col / cols) * this.frameHeight;
        } else if (this.sprite === rengokuSprite) {
            const cols = 8; // given in your spec
            sx = (this.col % cols) * this.frameWidth;
            sy = Math.floor(this.col / cols) * this.frameHeight;
        } else {
            // Eren (row/col system)
            sx = this.col * this.frameWidth;
            sy = this.row * this.frameHeight;
        }

        ctx.save();
        if (this.facing === 'left') {
            ctx.translate(this.x + this.drawWidth, 0);
            ctx.scale(-1, 1);
            ctx.drawImage(this.sprite, sx, sy, this.frameWidth, this.frameHeight,
            0, this.y, this.drawWidth, this.drawHeight);
        } else {
            ctx.drawImage(this.sprite, sx, sy, this.frameWidth, this.frameHeight,
            this.x, this.y, this.drawWidth, this.drawHeight);
        }
        ctx.restore();

        // Optional: ID tag
        ctx.fillStyle = '#111827';
        ctx.font = '12px Inter';
        ctx.fillText(`P${this.id}`, this.x + 4, this.y - 6);
        };


      this.jump = function() {
        if (!this.alive) return;
        if (this.y === this.initialY && !this.isDown) this.yv = -settings.jumpPower;
      }


      this.getSpriteRect = function() {
            const padX = 12, padY = 16;   // base padding
            let hitboxX = this.x + padX;
            let hitboxY = this.y + padY;
            let hitboxW = this.drawWidth - padX*2;
            let hitboxH = this.drawHeight - padY*2;

            // Adjust hitbox specifically for Player 2
            if (this.id === 1) {
                hitboxY += 5;       // move 5px down
            }

            // Adjust hitbox specifically for Player 2
            if (this.id === 2) {
                hitboxX += 12;      // move 12px to the right
                hitboxY -= 5;       // move 5px up
                hitboxW -= 60;      // shrink width by 60px
                hitboxH -= 0;      // shrink height by 0px
            }

            // Adjust hitbox specifically for Player 3
            if (this.id === 3) {
                hitboxX += 14;      // move 14px to the right
                hitboxY += 5;       // move 5px down
                hitboxW -= 60;      // shrink width by 60px
                hitboxH -= 0;      // shrink height by 0px
            }

            

            // Only adjust for Player 2 when facing left
            if (this.id === 2 && this.facing === 'left') {
                hitboxX += 40; // shift right by 100 pixels (adjust as needed)
            }
            // Only adjust for Player 3 when facing left
            if (this.id === 3 && this.facing === 'left') {
                hitboxX += 30; // shift right by 100 pixels (adjust as needed)
            }

            return { x: hitboxX, y: hitboxY, w: hitboxW, h: hitboxH };
        
        };


    }

    // Brick
    function Brick(x, y, w, h, speed, color, type, speedX = 0) {
        this.x = x; this.y = y; this.w = w; this.h = h;
        this.speed = speed; this.color = color; this.type = type; this.speedX = speedX;
        this.falling = false;
        this.triggeredBy = null;

        // animation state (only for horizontal bricks)
        this.cursedFrame = 0;
        this.frameTimer = 0;
        this.frameInterval = 8; 
        this.isRight = true;
        this.isLeft = false;

        this.update = function() {
            if (this.type === 'vertical') {
            this.y += this.speed;
            } else if (this.type === 'horizontal') {
            this.x += this.speedX;

            // set direction flags from movement
            if (this.speedX > 0) {
                this.isRight = true;
                this.isLeft = false;
            } else if (this.speedX < 0) {
                this.isRight = false;
                this.isLeft = true;
            }

            // frame update logic
            this.frameTimer++;
            if (this.frameTimer >= this.frameInterval) {
                this.cursedFrame = (this.cursedFrame + 1) % 6; 
                this.frameTimer = 0;
            }
            }
        }

        this.draw = function() {
        if (this.type === 'horizontal') {
            let frameX = this.cursedFrame * 134;
            let frameY = 0;

            let drawWidth = 134 * 1.35;  // double width
            let drawHeight = 85 * 1.35;  // double height

            if (this.isRight) {
                ctx.drawImage(
                    cursedImg,
                    frameX, frameY, 134, 85,
                    this.x, this.y, drawWidth, drawHeight
                );
            } else if (this.isLeft) {
                ctx.save();
                ctx.scale(-1, 1);
                ctx.drawImage(
                    cursedImg,
                    frameX, frameY, 134, 85,
                    -this.x - drawWidth, this.y, drawWidth, drawHeight
                );
                ctx.restore();
            }
        } else {
            // vertical stays simple rectangle
            ctx.fillStyle = this.color;
            ctx.fillRect(this.x, this.y, this.w, this.h);
        }
    }

    }

    function padHitbox(p) {
      const padX = 12, padY = 16;
      return { x: p.x + padX, y: p.y + padY, w: p.drawWidth - padX*2, h: p.drawHeight - padY*2 };
    }
    function aabb(a,b){
      return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
    }

    // Spawning
    function spawnVerticalRow() {
      const bw = settings.baseBrickSize, bh = settings.baseBrickSize;
      const total = Math.floor(canvas.width / (bw + settings.brickMargin));

      const gaps = [];
      while (gaps.length < 2) {
        const r = Math.floor(Math.random() * total);
        if (!gaps.includes(r)) gaps.push(r);
      }

      const color = `hsl(${Math.random()*360},70%,50%)`;
      let spd = settings.brickSpeed + Math.floor(score / 100) * 0.5;
      if (score >= 600) spd = settings.brickSpeed * 2 + Math.floor(score / 100) * 0.5;

      for (let i=0;i<total;i++){
        if (!gaps.includes(i)) {
          const x = i * (bw + settings.brickMargin);
          bricks.push(new Brick(x, -bh, bw, bh, spd, color, 'vertical'));
        }
      }
      verticalRowCount++;
    }

    // Spawning horizontal obstacle
    function spawnHorizontalObstacle() {
        const bw = 50 * 1.35; // double width
        const bh = 40 * 1.35; // double height
        let spd = 6;
        if (score >= 400) spd = 12;
        else if (score >= 250) spd = 6;

        // randomly choose spawn side: left or right
        const spawnLeft = Math.random() < 0.5;

        const startX = spawnLeft ? -bw : canvas.width;
        const speedX = spawnLeft ? spd : -spd;

        // raised 30px higher than before
        const y = canvas.height - 110 - 60;

        bricks.push(new Brick(startX, y, bw, bh, 0, '#cc3333', 'horizontal', speedX));
        verticalRowCount = 0;
    }


    function drawHUD() {
      ctx.fillStyle = '#111827';
      ctx.font = '20px Inter';
      ctx.textAlign = 'left';
      ctx.fillText(`Score: ${Math.floor(score)}`, 16, 32);
    }

    function everyoneDead() {
      return players.filter(p => p.alive).length === 0;
    }
    function aliveCount() {
      return players.filter(p => p.alive).length;
    }

    function endGameCompetitiveIfNeeded() {
      const alive = players.filter(p => p.alive);
      if (mode === 'multi' || mode === 'triple') {
        if (alive.length <= 1) {
          isOver = true;
          gameState = 'gameover';
          showResultsCompetitive(alive[0] || null);
          return true;
        }
      }
      return false;
    }

    function showResultsCompetitive(winner) {
      // Placements from deathOrder (earliest death = lower placement)
      const allIds = players.map(p=>p.id);
      const eliminatedIds = deathOrder.map(d=>d.id);
      const survivorIds = allIds.filter(id => !eliminatedIds.includes(id));
      const placements = [];

      // Losers in reverse death time (last to die ranks higher among eliminated)
      const deathsSorted = [...deathOrder].sort((a,b)=>a.time - b.time); // first to die first
      const losers = deathsSorted.map(d => d.id);

      // If a winner exists, they are first
      if (winner) placements.push(winner.id);

      // Then remaining survivors (should be none, but safe)
      placements.push(...survivorIds.filter(id => id !== (winner && winner.id)));

      // Then losers from last to first for 2nd/3rd etc
      placements.push(...losers.reverse().filter(id => !placements.includes(id)));

      // Build table
      const rankLabel = (i) => (i===0?'1st':i===1?'2nd':'3rd');
      let html = '';
      html += `<p class="mb-2"><strong>Mode:</strong> ${mode==='multi'?'Multiplayer (2P)':'Triple Player (3P)'} • <strong>Score:</strong> ${Math.floor(score)}</p>`;
      html += `<table class="table"><thead><tr><th>Place</th><th>Player</th><th>Survival (s)</th></tr></thead><tbody>`;
      placements.forEach((pid, idx) => {
        const p = players.find(pp=>pp.id===pid);
        const secs = Math.max(0, Math.round(p.survivalTime/100)/10); // one decimal
        html += `<tr><td>${rankLabel(idx)}</td><td>P${pid}</td><td>${secs}</td></tr>`;
      });
      html += `</tbody></table>`;
      resultsBlock.innerHTML = html;
      gameOver.classList.add('show');
      ingameMenuBtn.style.display = 'none';
    }

    function showResultsCoopOrSolo(loserId=null) {
      let title = mode==='solo' ? 'Game Over' : 'Co-op Game Over';
      const secs = Math.max(0, Math.round(Math.max(...players.map(p=>p.survivalTime))/100)/10);
      const who = loserId ? ` • Player ${loserId} was hit` : '';
      const html = `
        <p class="mb-2"><strong>${title}</strong>${who}</p>
        <p class="mb-2"><strong>Score:</strong> ${Math.floor(score)}</p>
        <table class="table"><thead><tr><th>Player</th><th>Survival (s)</th></tr></thead>
        <tbody>
          ${players.map(p=>`<tr><td>P${p.id}</td><td>${Math.round(p.survivalTime/100)/10}</td></tr>`).join('')}
        </tbody></table>
      `;
      resultsBlock.innerHTML = html;
      gameOver.classList.add('show');
      ingameMenuBtn.style.display = 'none';
    }

    function resetCommon() {
      score = 0;
      bricks = [];
      rowSpawnCounter = 0;
      verticalRowCount = 0;
      isOver = false;
      deathOrder = [];
      lastTimestamp = performance.now();
      resize();
    }

    function initPlayersForMode() {
      players = [];
      const groundY = canvas.height - 140;
      if (mode === 'solo') {
        players.push(new Player(1, canvas.width/2 - 34, groundY, { left:'a', right:'d', down:'s', up:'w' }));
      } else if (mode === 'coop' || mode === 'multi') {
        players.push(new Player(1, canvas.width/3 - 34, groundY, { left:'a', right:'d', down:'s', up:'w' }));
        players.push(new Player(
        2,
        canvas.width*2/3 - 34,
        groundY,
        { left:'ArrowLeft', right:'ArrowRight', down:'ArrowDown', up:'ArrowUp' },
        kimetsuSprite, // sprite
        100,           // frame width
        64             // frame height
        ));
      } else { // triple
        players.push(new Player(1, canvas.width/4 - 34, groundY, { left:'a', right:'d', down:'s', up:'w' }));
        players.push(new Player(
        2,
        canvas.width*2/3 - 34,
        groundY,
        { left:'ArrowLeft', right:'ArrowRight', down:'ArrowDown', up:'ArrowUp' },
        kimetsuSprite, // sprite
        100,           // frame width
        64             // frame height
        ));
        players.push(new Player(
        3,
        canvas.width*3/4 - 34,
        groundY,
        { left:'j', right:'l', down:'k', up:'i' },
        rengokuSprite, // use Rengoku sprite
        105,           // frame width
        68             // frame height
        ));
      }
    }

    function startGame() {
      menu.classList.remove('show');
      instructions.classList.remove('show');
      gameOver.classList.remove('show');
      pauseOverlay.classList.remove('show');

      resetCommon();
      initPlayersForMode();
      gameState = 'playing';
      ingameMenuBtn.style.display = 'block';

      if (!listenersAdded) {
        document.addEventListener('keydown', onKeyDown);
        document.addEventListener('keyup', onKeyUp);
        ingameMenuBtn.addEventListener('click', onMenuClick);
        resumeBtn.addEventListener('click', resumeFromPause);
        restartBtn.addEventListener('click', restartSameMode);
        toMenuBtn.addEventListener('click', backToMainMenu);
        playAgainBtn.addEventListener('click', restartSameMode);
        gameOverMenuBtn.addEventListener('click', backToMainMenu);
        listenersAdded = true;
      }

      lastTimestamp = performance.now();
      loop();
    }

    function pauseGame() {
      if (gameState !== 'playing') return;
      gameState = 'paused';
      pauseOverlay.classList.add('show');
    }
    function resumeFromPause() {
      if (gameState !== 'paused') return;
      gameState = 'playing';
      pauseOverlay.classList.remove('show');
      lastTimestamp = performance.now();
      loop();
    }
    function onMenuClick() { pauseGame(); }

    function restartSameMode() {
      pauseOverlay.classList.remove('show');
      gameOver.classList.remove('show');
      startGame(); // uses existing `mode`
    }
    function backToMainMenu() {
      cancelAnimationFrame(rafId);
      gameOver.classList.remove('show');
      pauseOverlay.classList.remove('show');
      ingameMenuBtn.style.display = 'none';
      gameState = 'menu';
      menu.classList.add('show');
      resize();
    }

    // Input
    function onKeyDown(e) {
      if (gameState === 'playing') {
        if (e.key === 'Escape') { pauseGame(); return; }
        players.forEach(p => {
          if (!p.alive) return;
          if (e.key === p.controls.left)  { p.isLeft = true;  p.facing = 'left'; }
          if (e.key === p.controls.right) { p.isRight = true; p.facing = 'right'; }
          if (e.key === p.controls.down)  { p.isDown = true; }
          if (e.key.toLowerCase() === p.controls.up) { p.jump(); }
          if (e.key === p.controls.up) { p.jump(); } // handle ArrowUp as well
        });
      } else if (gameState === 'menu' && e.key === 'Enter' && mode) {
        startGame();
      }
    }
    function onKeyUp(e) {
      if (gameState !== 'playing') return;
      players.forEach(p => {
        if (e.key === p.controls.left)  p.isLeft = false;
        if (e.key === p.controls.right) p.isRight = false;
        if (e.key === p.controls.down)  p.isDown = false;
      });
    }

    function pixelPerfectCollision(player, brick, ctx) {
    // Only check overlapping region
    const rect = player.getSpriteRect();
    const startX = Math.max(rect.x, brick.x);
    const startY = Math.max(rect.y, brick.y);
    const endX   = Math.min(rect.x + rect.w, brick.x + brick.w);
    const endY   = Math.min(rect.y + rect.h, brick.y + brick.h);


    if (startX >= endX || startY >= endY) return false; // no overlap

    // Offscreen canvas for sprite
    const off = document.createElement('canvas');
    off.width = player.frameWidth;
    off.height = player.frameHeight;
    const offCtx = off.getContext('2d');

    // Draw sprite frame
    let sx, sy;
    if (player.sprite === kimetsuSprite) {
        const cols = 10;
        sx = (player.col % cols) * player.frameWidth;
        sy = Math.floor(player.col / cols) * player.frameHeight;
    } else {
        sx = player.col * player.frameWidth;
        sy = player.row * player.frameHeight;
    }
    offCtx.drawImage(player.sprite, sx, sy, player.frameWidth, player.frameHeight, 0, 0, player.frameWidth, player.frameHeight);

    const data = offCtx.getImageData(0, 0, player.frameWidth, player.frameHeight).data;

    // Loop only over overlapping pixels
    for (let y = startY; y < endY; y++) {
        for (let x = startX; x < endX; x++) {
        const px = Math.floor((x - player.x) / player.drawWidth * player.frameWidth);
        const py = Math.floor((y - player.y) / player.drawHeight * player.frameHeight);
        const idx = (py * player.frameWidth + px) * 4;
        const alpha = data[idx + 3];
        if (alpha > 0) {
            return true;
        }
        }
    }

    return false;
    }


    function updateAndDrawBricksAndCollisions() {
      // Trigger fast-fall when brick reaches any player's Y
      for (const brick of bricks) {
        if (brick.type === 'vertical' && !brick.falling) {
          // Check against alive players
          for (const p of players) {
            if (!p.alive) continue;
            if (brick.y >= p.y) {
              brick.falling = true;
              brick.speed = settings.fastFallSpeed;
              brick.triggeredBy = p.id;
              break;
            }
          }
        }
      }

      // Update + draw
      for (let i = bricks.length - 1; i >= 0; i--) {
        const b = bricks[i];
        b.update();
        b.draw();

        // Check collisions with players
        for (const p of players) {
          if (!p.alive) continue;
          if (pixelPerfectCollision(p, b, ctx)) {
            // collision logic remains the same
            if (mode === 'coop') {
                if (b.type === 'vertical' && b.falling && b.triggeredBy !== null && b.triggeredBy !== p.id) {
                continue; // immunity
                }
                isOver = true; gameState = 'gameover';
                showResultsCoopOrSolo(p.id);
                return;
            }
            if (mode === 'solo') {
                isOver = true; gameState = 'gameover';
                showResultsCoopOrSolo(1);
                return;
            }
            p.alive = false;
            deathOrder.push({ id:p.id, time: performance.now() - startTimeMs });
            if (endGameCompetitiveIfNeeded()) return;
            }

        }

        // Cleanup off-screen
        if (b.type === 'vertical' && b.y > canvas.height) bricks.splice(i,1);
        if (b.type === 'horizontal' && (b.x + b.w < 0 || b.x > canvas.width)) bricks.splice(i,1);
      }
    }

    let startTimeMs = 0;
    function loop(ts) {
      if (gameState !== 'playing') { cancelAnimationFrame(rafId); return; }
      rafId = requestAnimationFrame(loop);

      const now = performance.now();
      const dt = now - lastTimestamp; // ms
      lastTimestamp = now;
      if (!startTimeMs) startTimeMs = now;

      ctx.clearRect(0,0,canvas.width,canvas.height);

      // Update players
      players.forEach(p => p.update(dt));

        // DEBUG: draw hitboxes
        players.forEach(p => {
            if (!p.alive) return;
            const hb = p.getSpriteRect();
            ctx.save();
            ctx.fillStyle = 'rgba(255,0,0,0.2)';
            ctx.fillRect(hb.x, hb.y, hb.w, hb.h);
            ctx.strokeStyle = 'red';
            ctx.lineWidth = 2;
            ctx.strokeRect(hb.x, hb.y, hb.w, hb.h);
            ctx.restore();
        });

      // Spawning pacing
      rowSpawnCounter++;
      let spawnRate = Math.max(settings.rowSpawnRate - Math.floor(score / 50) * 5, 60);
      if (score >= 600) spawnRate = 120;
      if (rowSpawnCounter >= spawnRate) {
        if (verticalRowCount < 3) spawnVerticalRow();
        else spawnHorizontalObstacle();
        rowSpawnCounter = 0;
      }

      // Bricks + collisions
      updateAndDrawBricksAndCollisions();
      if (isOver) return;

      // Draw players
      players.forEach(p => p.draw());

      // Score
      score += 0.1;
      drawHUD();
    }

    /* ---------- MENU WIRING ---------- */
    let selectedChip = null;
    modeChips.querySelectorAll('.chip').forEach(chip => {
      chip.addEventListener('click', () => {
        modeChips.querySelectorAll('.chip').forEach(c=>c.classList.remove('selected'));
        chip.classList.add('selected');
        selectedChip = chip.dataset.mode;
        mode = selectedChip;
        startBtn.disabled = false;
      });
    });
    instructionsBtn.addEventListener('click', () => {
      menu.classList.remove('show');
      instructions.classList.add('show');
      gameState = 'instructions';
    });
    backFromInstructions.addEventListener('click', () => {
      instructions.classList.remove('show');
      menu.classList.add('show');
      gameState = 'menu';
    });
    startBtn.addEventListener('click', () => { if (mode) startGame(); });

    // Also allow ESC in playing mode to pause
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && gameState === 'playing') pauseGame();
    });

  })();
  </script>
</body>
</html>
