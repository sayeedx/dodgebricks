<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Dodge the Bricks</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body {
      font-family: 'Inter', sans-serif;
      background-color: #f0f0f0;
      display: flex; justify-content: center; align-items: center;
      height: 100vh; margin: 0; overflow: hidden;
    }
    #game-container {
      width: 100%; height: 100%; max-width: 800px; max-height: 600px;
      position: relative; background-color: #fff; border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1); overflow: hidden;
    }
    canvas { display: block; }
    #start-screen, #game-over-screen {
      position: absolute; inset: 0;
      display: flex; flex-direction: column; justify-content: center; align-items: center;
      background: rgba(0,0,0,0.8); color: #fff; z-index: 100; text-align: center;
    }
    #game-over-screen { display: none; }
    #start-button, #restart-button {
      padding: 1rem 2rem; font-size: 1.25rem; font-weight: 700;
      border: 0; border-radius: 8px; cursor: pointer; transition: .2s;
      box-shadow: 0 4px 6px rgba(0,0,0,.1);
    }
    #start-button { background: #3b82f6; }
    #start-button:hover { background: #2563eb; transform: translateY(-2px); }
    #restart-button { background: #22c55e; }
    #restart-button:hover { background: #16a34a; transform: translateY(-2px); }
  </style>
</head>
<body>
  <div id="game-container" class="rounded-xl shadow-lg">
    <div id="start-screen">
      <h1 class="text-4xl md:text-5xl font-extrabold mb-4">Dodge the Bricks</h1>
      <p class="text-xl mb-8">Space = Jump • ←/→ = Move • ↓ = Crouch</p>
      <button id="start-button">Start Game</button>
    </div>

    <div id="game-over-screen">
      <h2 class="text-4xl md:text-5xl font-extrabold mb-4">Game Over!</h2>
      <p class="text-xl mb-2">Your Score:</p>
      <p id="final-score" class="text-5xl md:text-6xl font-extrabold text-blue-400 mb-8">0</p>
      <button id="restart-button">Restart</button>
    </div>

    <canvas id="gameCanvas"></canvas>
  </div>

  <script>
  (function () {
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    const startScreen = document.getElementById("start-screen");
    const startButton = document.getElementById("start-button");
    const gameOverScreen = document.getElementById("game-over-screen");
    const finalScoreElement = document.getElementById("final-score");
    const restartButton = document.getElementById("restart-button");

    // --- Load sprite (57x76 per frame, 48 frames total; 4 rows x 12 cols) ---
    const erenSprite = new Image();
    erenSprite.src = "eren.png";

    let score = 0;
    let player = null;
    let bricks = [];
    let isGameOver = false;
    let animationFrameId;
    let rowSpawnCounter = 0;
    let verticalRowCount = 0;

    const settings = {
      playerSpeed: 8,
      brickSpeed: 1.5,
      rowSpawnRate: 240,
      baseBrickSize: 40,
      brickMargin: 25,
      jumpPower: 12,
      gravity: 0.5
    };

    let gameState = "start";

    // ---------------- Player using sprite ----------------
    function Player(x, y) {
      this.x = x;
      this.y = y;
      this.initialY = y;

      // slightly bigger on screen (about 1.2x)
      this.drawWidth = 68;   // display size (dest)
      this.drawHeight = 91;

      // sprite frame size (source)
      this.frameWidth = 57;
      this.frameHeight = 76;

      // controls/state
      this.isMovingLeft = false;
      this.isMovingRight = false;
      this.isCrouching = false;
      this.facing = "right"; // start facing right
      this.yVelocity = 0;

      // animation
      this.col = 0;    // frame index within row
      this.row = 0;    // 0 idle, 1 crouch, 2 run, 3 jump
      this.timer = 0;
      this.step = 6;   // lower = faster animation
      this.colsPerRow = 12;  // 48 frames / 4 rows

      // frame caps per action (feel free to tweak)
      this.maxCols = { idle: 12, crouch: 12, run: 12, jump: 12 };

      this.update = function () {
        // movement
        if (this.isMovingLeft)  this.x -= settings.playerSpeed;
        if (this.isMovingRight) this.x += settings.playerSpeed;

        // physics (jump)
        this.y += this.yVelocity;
        this.yVelocity += settings.gravity;
        if (this.y >= this.initialY) {
          this.y = this.initialY;
          this.yVelocity = 0;
        }

        // clamp to canvas
        if (this.x < 0) this.x = 0;
        if (this.x + this.drawWidth > canvas.width) {
          this.x = canvas.width - this.drawWidth;
        }

        // choose row by action mapping provided:
        // row 0 idle, 1 crouch, 2 run, 3 jump
        if (this.isCrouching && this.y === this.initialY) {
          this.row = 1; // crouch
        } else if (this.y < this.initialY) {
          this.row = 3; // jump
        } else if (this.isMovingLeft || this.isMovingRight) {
          this.row = 2; // run
        } else {
          this.row = 0; // idle
        }

        // animation tick
        this.timer++;
        if (this.timer >= this.step) {
          this.timer = 0;
          this.col = (this.col + 1) % (
            this.row === 0 ? this.maxCols.idle  :
            this.row === 1 ? this.maxCols.crouch:
            this.row === 2 ? this.maxCols.run   :
                             this.maxCols.jump
          );
        }
      };

      this.draw = function () {
        // source rect
        const sx = this.col * this.frameWidth;
        const sy = this.row * this.frameHeight;

        ctx.save();
        if (this.facing === "left") {
          // flip horizontally around the character's left edge
          ctx.translate(this.x + this.drawWidth, 0);
          ctx.scale(-1, 1);
          ctx.drawImage(
            erenSprite, sx, sy, this.frameWidth, this.frameHeight,
            0, this.y, this.drawWidth, this.drawHeight
          );
        } else {
          ctx.drawImage(
            erenSprite, sx, sy, this.frameWidth, this.frameHeight,
            this.x, this.y, this.drawWidth, this.drawHeight
          );
        }
        ctx.restore();
      };

      this.jump = function () {
        if (this.y === this.initialY && !this.isCrouching) {
          this.yVelocity = -settings.jumpPower;
        }
      };
    }

    // ---------------- Obstacles ----------------
    function Brick(x, y, width, height, speed, color, type, speedX = 0) {
      this.x = x; this.y = y; this.width = width; this.height = height;
      this.speed = speed; this.color = color; this.type = type; this.speedX = speedX;

      this.update = function () {
        if (this.type === "vertical") this.y += this.speed;
        else if (this.type === "horizontal") this.x += this.speedX;
      };

      this.draw = function () {
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, this.width, this.height);
      };
    }

    // ---------------- Setup ----------------
    function init() {
      canvas.width  = Math.min(800, window.innerWidth);
      canvas.height = Math.min(600, window.innerHeight);

      score = 0;
      isGameOver = false;
      bricks = [];
      rowSpawnCounter = 0;
      verticalRowCount = 0;

      // start a bit higher on the screen (not hugging the floor)
      player = new Player(canvas.width / 2 - 34, canvas.height - 140);

      document.addEventListener("keydown", handleKeyDown);
      document.addEventListener("keyup", handleKeyUp);
    }

    // ---------------- Controls ----------------
    function handleKeyDown(e) {
      if (gameState === "playing") {
        if (e.key === "ArrowLeft" || e.key === "a") {
          player.isMovingLeft = true;
          player.facing = "left";    // flip on press
        } else if (e.key === "ArrowRight" || e.key === "d") {
          player.isMovingRight = true;
          player.facing = "right";   // face right on press
        } else if (e.key === " ") {
          player.jump();
        } else if (e.key === "ArrowDown" || e.key === "s") {
          player.isCrouching = true;
        }
      } else if (e.key === " " && gameState === "start") {
        startGame();
      } else if (e.key === " " && gameState === "gameover") {
        restartGame();
      }
    }
    function handleKeyUp(e) {
      if (gameState === "playing") {
        if (e.key === "ArrowLeft" || e.key === "a")   player.isMovingLeft = false;
        if (e.key === "ArrowRight" || e.key === "d")  player.isMovingRight = false;
        if (e.key === "ArrowDown" || e.key === "s")   player.isCrouching = false;
      }
    }

    // ---------------- Spawning ----------------
    function spawnVerticalRow() {
      const brickWidth = settings.baseBrickSize;
      const brickHeight = settings.baseBrickSize;
      const totalBricksInRow = Math.floor(canvas.width / (brickWidth + settings.brickMargin));

      // pick 2 gaps
      const gaps = [];
      while (gaps.length < 2) {
        const r = Math.floor(Math.random() * totalBricksInRow);
        if (!gaps.includes(r)) gaps.push(r);
      }

      const brickColor = `hsl(${Math.random() * 360},70%,50%)`;
      let currentBrickSpeed = settings.brickSpeed + Math.floor(score / 100) * 0.5;

      // faster after high score (optional tweak)
      if (score >= 600) currentBrickSpeed = settings.brickSpeed * 2 + Math.floor(score / 100) * 0.5;

      for (let i = 0; i < totalBricksInRow; i++) {
        if (!gaps.includes(i)) {
          const x = i * (brickWidth + settings.brickMargin);
          bricks.push(new Brick(x, -brickHeight, brickWidth, brickHeight, currentBrickSpeed, brickColor, "vertical"));
        }
      }
      verticalRowCount++;
    }

    function spawnHorizontalObstacle() {
      const brickWidth = 50, brickHeight = 40;
      let brickSpeed = 6;
      if (score >= 400) brickSpeed = 12;
      else if (score >= 250) brickSpeed = 6;

      const startX = Math.random() < 0.5 ? -brickWidth : canvas.width;
      const speedX = startX === -brickWidth ? brickSpeed : -brickSpeed;
      const yPosition = canvas.height - 110; // aligned with slightly higher player

      bricks.push(new Brick(startX, yPosition, brickWidth, brickHeight, 0, "#cc3333", "horizontal", speedX));
      verticalRowCount = 0;
    }

    // ---------------- Collision (tighter hitbox) ----------------
    function checkCollision(obstacle, player) {
      // shrink hitbox so only visible body counts (avoid transparent padding)
      const padX = 12, padY = 16;
      const px = player.x + padX;
      const py = player.y + padY;
      const pw = player.drawWidth  - padX * 2;
      const ph = player.drawHeight - padY * 2;

      return (
        px < obstacle.x + obstacle.width &&
        px + pw > obstacle.x &&
        py < obstacle.y + obstacle.height &&
        py + ph > obstacle.y
      );
    }

    // ---------------- HUD ----------------
    function drawScore() {
      ctx.fillStyle = "#333";
      ctx.font = "24px Inter";
      ctx.textAlign = "right";
      ctx.fillText(`Score: ${Math.floor(score)}`, canvas.width - 20, 40);
    }

    // ---------------- Main Loop ----------------
    function gameLoop() {
      if (isGameOver) { cancelAnimationFrame(animationFrameId); return; }
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      player.update();
      player.draw();

      // spawn pacing
      rowSpawnCounter++;
      let currentSpawnRate = Math.max(settings.rowSpawnRate - Math.floor(score / 50) * 5, 60);
      if (score >= 600) currentSpawnRate = 120; // optional fixed faster rate later

      if (rowSpawnCounter >= currentSpawnRate) {
        if (verticalRowCount < 3) spawnVerticalRow();
        else spawnHorizontalObstacle();
        rowSpawnCounter = 0;
      }

      // update/draw obstacles
      for (let i = bricks.length - 1; i >= 0; i--) {
        const brick = bricks[i];

        // --- RESTORED: when a vertical brick row reaches player's Y, drop fast ---
        if (brick.type === "vertical" && brick.y >= player.y) {
          brick.speed = 30; // “completely come down”
        }

        brick.update();
        brick.draw();

        // collision check with tighter hitbox
        if (checkCollision(brick, player)) {
          isGameOver = true;
          gameState = "gameover";
          showGameOverScreen();
          break;
        }

        // cleanup off-screen
        if (brick.type === "vertical" && brick.y > canvas.height) bricks.splice(i, 1);
        if (brick.type === "horizontal" && (brick.x + brick.width < 0 || brick.x > canvas.width)) bricks.splice(i, 1);
      }

      score += 0.1;
      drawScore();
      animationFrameId = requestAnimationFrame(gameLoop);
    }

    // ---------------- State transitions ----------------
    function startGame() {
      startScreen.style.display = "none";
      gameOverScreen.style.display = "none";
      gameState = "playing";
      init();
      gameLoop();
    }
    function restartGame() { startGame(); }
    function showGameOverScreen() {
      finalScoreElement.textContent = Math.floor(score);
      gameOverScreen.style.display = "flex";
    }

    // bootstrap
    init();
    startButton.addEventListener("click", startGame);
    restartButton.addEventListener("click", restartGame);
    window.addEventListener("resize", () => { if (gameState !== "playing") init(); });
  })();
  </script>
</body>
</html>
